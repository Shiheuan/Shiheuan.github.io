<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="0x00 Emmmmm有人用这个搞我，问我知不知道，在一个 update 函数中实例化了一个对象，那么这些函数在后续的几帧中的调用情况是啥样的，让我写个坐标轴，这谁受得了啊？ （其他还有比方说 Unity 协程的原理，我看过，居然忘了！） 所以今天我不管别的了就来看打印输出了，让脚本自己把每一帧，执行的函数，打印一下。其实网上有很多这样的讲解，但是看别人的科普终究不如自己实践，所以我决定花点时间从">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity 时间方法执行顺序（生命周期）">
<meta property="og:url" content="http://shiheuan.github.io/2019/06/30/UnityLifecycle/index.html">
<meta property="og:site_name" content="Yuan Shi&#39;s Blog">
<meta property="og:description" content="0x00 Emmmmm有人用这个搞我，问我知不知道，在一个 update 函数中实例化了一个对象，那么这些函数在后续的几帧中的调用情况是啥样的，让我写个坐标轴，这谁受得了啊？ （其他还有比方说 Unity 协程的原理，我看过，居然忘了！） 所以今天我不管别的了就来看打印输出了，让脚本自己把每一帧，执行的函数，打印一下。其实网上有很多这样的讲解，但是看别人的科普终究不如自己实践，所以我决定花点时间从">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/unity3.4lifecycle.png">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/monobehaviour_flowchart.svg">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/Hierarchy.png">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-overall.png">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-print2.png">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-print3.png">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-print4.png">
<meta property="og:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-timeline.png">
<meta property="article:published_time" content="2019-06-30T05:06:00.000Z">
<meta property="article:modified_time" content="2025-03-24T07:45:07.944Z">
<meta property="article:author" content="Shiheuan">
<meta property="article:tag" content="unity">
<meta property="article:tag" content="foundations">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shiheuan.github.io/2019/06/30/UnityLifecycle/unity3.4lifecycle.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/new_favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/new_favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/new_favicon.png">
        
      
    
    <!-- title -->
    <title>Unity 时间方法执行顺序（生命周期）</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2019/07/09/PlayerPrefs/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2019/06/10/AnonymousMethod/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://shiheuan.github.io/2019/06/30/UnityLifecycle/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&text=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&is_video=false&description=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Unity 时间方法执行顺序（生命周期）&body=Check out this article: http://shiheuan.github.io/2019/06/30/UnityLifecycle/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&name=Unity 时间方法执行顺序（生命周期）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&t=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-Emmmmm"><span class="toc-number">1.</span> <span class="toc-text">0x00 Emmmmm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-FlowChart"><span class="toc-number">2.</span> <span class="toc-text">0x01 FlowChart</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Conclusion"><span class="toc-number">3.</span> <span class="toc-text">0x02 Conclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-Test"><span class="toc-number">4.</span> <span class="toc-text">0x03 Test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-Translate"><span class="toc-number">5.</span> <span class="toc-text">0x04 Translate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First-Scene-Load"><span class="toc-number">5.1.</span> <span class="toc-text">First Scene Load</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gt-%E6%B3%A8%E6%84%8F%E5%BD%93%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%97%B6%EF%BC%8C%E5%85%A8%E9%83%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84-Awake-%E5%92%8C-OnEnable-%E6%96%B9%E6%B3%95%E9%83%BD%E5%B0%86%E4%BC%9A%E5%9C%A8-Start%E3%80%81Update-%E7%AD%89%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E5%9C%A8%E6%B8%B8%E6%88%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">&gt; 注意当对象添加到场景中时，全部脚本中的 Awake 和 OnEnable 方法都将会在 Start、Update 等方法被调用之前执行。当然，在游戏过程中实例化对象时，不能被强制执行此方法。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Editor"><span class="toc-number">6.1.</span> <span class="toc-text">Editor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gt-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">&gt; 编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Before-the-first-frame-update"><span class="toc-number">7.1.</span> <span class="toc-text">Before the first frame update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-between-frames"><span class="toc-number">7.2.</span> <span class="toc-text">In between frames</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B8%A7%E4%B9%8B%E9%97%B4"><span class="toc-number">7.3.</span> <span class="toc-text">在帧之间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Update-Order"><span class="toc-number">7.4.</span> <span class="toc-text">Update Order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animation-update-loop"><span class="toc-number">7.5.</span> <span class="toc-text">Animation update loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rendering"><span class="toc-number">7.6.</span> <span class="toc-text">Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coroutines"><span class="toc-number">7.7.</span> <span class="toc-text">Coroutines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-the-Object-is-destroyed"><span class="toc-number">7.8.</span> <span class="toc-text">When the Object is destroyed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-quitting"><span class="toc-number">7.9.</span> <span class="toc-text">When quitting</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0xff"><span class="toc-number">8.</span> <span class="toc-text">0xff</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Unity 时间方法执行顺序（生命周期）
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Shiheuan</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-06-30T05:06:00.000Z" class="dt-published" itemprop="datePublished">2019-06-30</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/foundations/" rel="tag">foundations</a>, <a class="p-category" href="/tags/unity/" rel="tag">unity</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="0x00-Emmmmm"><a href="#0x00-Emmmmm" class="headerlink" title="0x00 Emmmmm"></a>0x00 Emmmmm</h2><p>有人用这个搞我，问我知不知道，在一个 update 函数中实例化了一个对象，那么这些函数在后续的几帧中的调用情况是啥样的，让我写个坐标轴，这谁受得了啊？</p>
<p>（其他还有比方说 Unity 协程的原理，我看过，居然忘了！）</p>
<p>所以今天我不管别的了就来看打印输出了，让脚本自己把每一帧，执行的函数，打印一下。其实网上有很多这样的讲解，但是看别人的科普终究不如自己实践，所以我决定花点时间从官方文档到写代码打印，理理清楚这些事件方法执行顺序（ Order of Excution for event functions ）。</p>
<h2 id="0x01-FlowChart"><a href="#0x01-FlowChart" class="headerlink" title="0x01 FlowChart"></a>0x01 FlowChart</h2><p>这是 2012 年，由 Richard Fine 总结的 unity 3.4 版本的生命周期图，很清晰：</p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/unity3.4lifecycle.png" alt=""></p>
<p>这是 unity 官方文档中 2018.4 版本的脚本生命周期流程图（script lifecycle flowchart）：</p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/monobehaviour_flowchart.svg" alt=""></p>
<p>有少部分的区别。</p>
<p>为了比较直观的对整个生命周期有更直观的理解，决定在一个场景中，尽量用到这些常用的函数，然后打印出相关的执行信息，特别是在每一帧具体执行了什么函数，这样也对后面实现游戏逻辑时应该在何处实现，有更深刻的理解哈。</p>
<p>今天的重点主要是常用的几个方法，Awake、OnEnable、Start、Update、OnDisable、OnDestory、OnGUI等，以及协程。</p>
<h2 id="0x02-Conclusion"><a href="#0x02-Conclusion" class="headerlink" title="0x02 Conclusion"></a>0x02 Conclusion</h2><p>为了节约时间，更有目的性的阅读实验部分，这里把结论提前，对照结论，可以在实验中找到相应的语句进行验证。</p>
<p>结论：</p>
<ul>
<li>单个脚本中方法的执行顺序 Awake -&gt; OnEnable -&gt; Start -&gt; Update.</li>
<li>帧更新的顺序 FixedUpdate( xN ) -&gt; Update -&gt; LateUpdate</li>
<li>开始运行时场景中所有有效（ active ）的对象脚本中的 Awake 和 OnEnable（ 脚本组件 enabled ）将会在在所有脚本的 Start 执行之前执行。</li>
<li>Start 只会在 Update 执行之前，执行一次。</li>
<li>Start 中开启的协程 yield 到帧结束，会在第二帧结束时（ LateUpdate 完成 ）继续。而在 Update 中开启的协程，会在本帧结束时继续。而 yield 一定时间则不会等到目标时刻的帧结束。</li>
<li>OnEnable 在每次脚本对象由 disabled 到 enabled，或挂载的对象由 inactive 到 active 时，都会执行。（ 但如果脚本本身是 disable 的，对象由 inactive 到 active 也不会执行 OnEnable ）</li>
<li>实例化的对象只有在 active 的时候，才会执行 Awake OnEnable Start Update（ 无论通过预制体还是场景内对象，本来在用作实例化时就没啥区别 ）</li>
<li>OnGUI 在暂停时也会执行诶。</li>
</ul>
<hr>
<p>补充：</p>
<ul>
<li>多个脚本中 Awake 方法的执行是随机的，官方没有给出这种随机的规则或理由。（Each GameObject’s Awake is called in a random order between objects. Because of this, you should use Awake to set up references between scripts, and use Start to pass any information back and forth.）</li>
<li>Destroy 方法在销毁一个对象时，并不是立即销毁，而是在下一次 Update 执行之前（所有对象的 Update 方法是统一执行，不会出现一个对象开始执行 Update 了，而另一个对象还在处理 FixedUpdate 这种情况）</li>
<li>介于上一条的，在调用 Destroy 方法后，可以继续访问此对象挂载的脚本中的方法或者其他组件，但在下一帧时，对象就会被销毁，指向对象的引用也会为空。</li>
<li>调用 Destroy 方法时会立即调用对象的 OnDisable （如果对象有效），但对于多个对象的销毁这两个方法没有严格的顺序关系（只与执行位置有关系，下一帧之前 OnDestroy）。</li>
</ul>
<h2 id="0x03-Test"><a href="#0x03-Test" class="headerlink" title="0x03 Test"></a>0x03 Test</h2><p>场景中为主要是通过 GameManager 启动协程，以及对 Cube 游戏对象，预制体进行实例化操作。Hierarchy 如下：</p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/Hierarchy.png" alt=""></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> updateCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> lateupdateCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> fixedupdateCount;</span><br><span class="line">    <span class="keyword">public</span> GameObject cubeActive;</span><br><span class="line">    <span class="keyword">public</span> GameObject cubeInact;</span><br><span class="line">    <span class="keyword">public</span> GameObject cubeObj;</span><br><span class="line">    <span class="keyword">public</span> GameObject cubePrefab;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On Awake.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On Start.&quot;</span>);</span><br><span class="line">        StartCoroutine(CoroutineInStart());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">CoroutineInStart</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart.&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>;</span><br><span class="line"></span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. After WaitForEndOfFrame(). yield 1&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> ob = GameObject.Instantiate(cubeObj);</span><br><span class="line">        <span class="keyword">var</span> pb = GameObject.Instantiate(cubePrefab);</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is Instantiated inactive.&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>;</span><br><span class="line"></span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. After WaitForFixedUpdate(). yield 2&quot;</span>);</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + cubeActive.GetComponent&lt;CubeController&gt;() + <span class="string">&quot; is disabled now.&quot;</span>);</span><br><span class="line">        cubeActive.GetComponent&lt;CubeController&gt;().enabled = <span class="literal">false</span>;</span><br><span class="line">        cubeActive.SetActive(<span class="literal">false</span>);</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is active now.&quot;</span>);</span><br><span class="line">        ob.SetActive(<span class="literal">true</span>);</span><br><span class="line">        pb.SetActive(<span class="literal">true</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>;</span><br><span class="line"></span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. After WaitForFixedUpdate(). yield 3&quot;</span>);</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + cubeActive.GetComponent&lt;CubeController&gt;() + <span class="string">&quot; is enabled now.&quot;</span>);</span><br><span class="line">        cubeActive.SetActive(<span class="literal">true</span>);</span><br><span class="line">        cubeActive.GetComponent&lt;CubeController&gt;().enabled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//ob.GetComponent&lt;CubeController&gt;().enabled = false;</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.1f</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. After WaitForSeconds(0.1f). yield 4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is inactive now.&quot;</span>);</span><br><span class="line">        ob.SetActive(<span class="literal">false</span>);</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is active now.&quot;</span>);</span><br><span class="line">        ob.SetActive(<span class="literal">true</span>);</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is destroyed now.&quot;</span>);</span><br><span class="line">        GameObject.Destroy(ob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On OnEnable.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On OnDisable.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        updateCount++;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On Update: &quot;</span> + updateCount + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (updateCount == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(CoroutineInUpdate3());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">CoroutineInUpdate3</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInUpdate3.&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>;</span><br><span class="line"></span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInUpdate3. After WaitForEndOfFrame().&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fixedupdateCount++;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On FixedUpdate: &quot;</span> + fixedupdateCount + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lateupdateCount++;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot; On LateUpdate: &quot;</span> + lateupdateCount + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span> + <span class="string">&quot;On OnDestroy.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//print(this + &quot;On OnGUI.&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-overall.png" alt=""></p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-print2.png" alt=""></p>
<p>补充实验:</p>
<p>针对两个个问题：在 Destroy 一个对象之后，即在销毁行后对这个对象的内容进行调用，是否能够正确调用其内容（包括但不限于，当前脚本，对象的某些组件）；Awake 方法执行顺序。</p>
<p>针对 Awake 猜测（不重要），做了一些测试，并查阅了官方文档，嗯，随机的。</p>
<p>关于 Destroy 的在协程中做了一些修改。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">CoroutineInStart</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.1f</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. After WaitForSeconds(0.1f). yield 4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is inactive now.&quot;</span>);</span><br><span class="line">    ob.SetActive(<span class="literal">false</span>);</span><br><span class="line">    print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is active now.&quot;</span>);</span><br><span class="line">    ob.SetActive(<span class="literal">true</span>);</span><br><span class="line">    print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; is destroyed now.&quot;</span>);</span><br><span class="line">    GameObject.Destroy(ob);</span><br><span class="line">    <span class="comment">// new below</span></span><br><span class="line">    ob.GetComponent&lt;CubeController&gt;().SayHi();  <span class="comment">// add a function print &quot;I can hear yaaaa&quot;</span></span><br><span class="line">    <span class="keyword">var</span> obcol = ob.GetComponent&lt;BoxCollider&gt;(); <span class="comment">// a cube has a box collider</span></span><br><span class="line">    print(obcol + <span class="string">&quot; can be find, too.&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>;</span><br><span class="line">    print(<span class="keyword">this</span> + <span class="string">&quot; On CoroutineInStart. &quot;</span> + ob + <span class="string">&quot; this Update End now.&quot;</span>);</span><br><span class="line">    print(ob + <span class="string">&quot;, ob is null? &quot;</span>);</span><br><span class="line">    print(obcol + <span class="string">&quot;, ob collider is null?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你是看了结论过来的吧，下面是打印输出：</p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-print3.png" alt=""></p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-print4.png" alt=""></p>
<h2 id="0x04-Translate"><a href="#0x04-Translate" class="headerlink" title="0x04 Translate"></a>0x04 Translate</h2><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2018.4/Documentation/Manual/ExecutionOrder.html">官网文档</a>的翻译：</p>
<p>（翻译完了才发现，Unity 中国现在有了自己的中文版文档（ 使用了 Unity Web，需要耐心等待 ），但版本是 2018.1 也可以参考这个<a target="_blank" rel="noopener" href="https://connect.unity.com/doc/Manual/ExecutionOrder">中文官方文档</a>）</p>
<h3 id="First-Scene-Load"><a href="#First-Scene-Load" class="headerlink" title="First Scene Load"></a>First Scene Load</h3><blockquote>
<p>场景首次加载</p>
</blockquote>
<hr>
<p>These functions get called when a scene starts (once for each object in the scene).</p>
<blockquote>
<p>当场景加载后，这些方法会被调用（场景中的每一个对象都会调用一次）。</p>
</blockquote>
<hr>
<ul>
<li>Awake: This function is always called before any Start functions and also just after a prefab is instantiated.(If a GameObject is inactive during start up Awake is not called until it is made active.)</li>
</ul>
<blockquote>
<p>Awake 方法的执行总是先于任意的 Start 方法，也会在一个预制体被实例化的时候。而如果一个游戏对象（ GameObject ）是无效（ inactive ）状态的，Awake 方法会等到它有效（ active ）时被调用。</p>
</blockquote>
<p>【ps 这里的 active inactive 是指 GameObject 的那个对勾吧】</p>
<hr>
<ul>
<li>OnEnable: (only called if the Object is active): This function is called just after the object is enabled. This happens when a MonoBehaviour instance is created, such as when a level is loaded or a GameObject with the script componenet is instantiated.</li>
</ul>
<blockquote>
<p>OnEnable 方法只针对那些有效（ active ）的对象有效，它会在对象激活的时候调用，这会发生在一个 MonoBehaviour 实例被创建的时候，比如场景加载时，或者挂在了脚本的游戏对象被实例化时。</p>
</blockquote>
<hr>
<ul>
<li>OnLevelWasLoaded: This function is executed to inform the game that a new level has been loaded.</li>
</ul>
<blockquote>
<p>这个方法被用来通知游戏新的场景已经装载好了。</p>
</blockquote>
<hr>
<p>Note that for objects added to the scene, the Awake and OnEnable functions for all scripts will be called before Start, Update, etc. are called for any of them. Naturally, this cannot be enforced when an object is instantiated during gameplay.</p>
<h2 id="gt-注意当对象添加到场景中时，全部脚本中的-Awake-和-OnEnable-方法都将会在-Start、Update-等方法被调用之前执行。当然，在游戏过程中实例化对象时，不能被强制执行此方法。"><a href="#gt-注意当对象添加到场景中时，全部脚本中的-Awake-和-OnEnable-方法都将会在-Start、Update-等方法被调用之前执行。当然，在游戏过程中实例化对象时，不能被强制执行此方法。" class="headerlink" title="&gt; 注意当对象添加到场景中时，全部脚本中的 Awake 和 OnEnable 方法都将会在 Start、Update 等方法被调用之前执行。当然，在游戏过程中实例化对象时，不能被强制执行此方法。"></a>&gt; 注意当对象添加到场景中时，全部脚本中的 Awake 和 OnEnable 方法都将会在 Start、Update 等方法被调用之前执行。当然，在游戏过程中实例化对象时，不能被强制执行此方法。</h2><h3 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h3><h2 id="gt-编辑器"><a href="#gt-编辑器" class="headerlink" title="&gt; 编辑器"></a>&gt; 编辑器</h2><ul>
<li>Reset: Reset is called to initialize the script’s properties when it is first attached to the object and also when the Reset command is used.</li>
</ul>
<blockquote>
<p>Reset 方法用来初始化脚本的属性，当脚本初次挂载到对象上或是执行了重置（ Reset ）命令时，会执行这个方法。</p>
</blockquote>
<hr>
<h3 id="Before-the-first-frame-update"><a href="#Before-the-first-frame-update" class="headerlink" title="Before the first frame update"></a>Before the first frame update</h3><blockquote>
<p>在第一帧更新之前</p>
</blockquote>
<hr>
<ul>
<li>Start: Start is called before the first frame update only if the script instance is enabled.</li>
</ul>
<blockquote>
<p>Start 方法在第一帧更新（ update ）之前被调用，当然，脚本实例必须是激活（ enabled ）的。</p>
</blockquote>
<hr>
<p>For objects added to the scene, the Start function will be called on all scripts before Update, etc. are called for any of them. Naturally, this cannot be enforced when an object is instantiated during gameplay.</p>
<blockquote>
<p>注意当对象添加到场景中时，全部脚本中的 Start 方法都将会在 Update 等方法被调用之前执行。当然，在游戏过程中实例化对象时，不能被强制执行此方法。</p>
</blockquote>
<hr>
<h3 id="In-between-frames"><a href="#In-between-frames" class="headerlink" title="In between frames"></a>In between frames</h3><blockquote>
<p>在帧与帧之间</p>
</blockquote>
<hr>
<h3 id="在帧之间"><a href="#在帧之间" class="headerlink" title="在帧之间"></a>在帧之间</h3><ul>
<li>OnApplicationPause: This is called at the end of the frame where the pause is detected, effectively between the normal frame updates. One extra frame will be issued after OnApplicationPause is called to allow the game to show graphics that indicate the paused state.</li>
</ul>
<blockquote>
<p>OnApplicationPause 方法会在暂停时，执行完当前帧后调用。实际上，实在两个正常的帧更新之间。在这个方法被调用后，会有额外的一帧出现，来显示表明游戏被暂停了。</p>
</blockquote>
<hr>
<h3 id="Update-Order"><a href="#Update-Order" class="headerlink" title="Update Order"></a>Update Order</h3><blockquote>
<p>更新顺序</p>
</blockquote>
<hr>
<p>When you’re keeping track of game logic and interactions, animations, camera positions, etc., there are a few different events you can use. The common pattern is to perform most tasks inside the Update function, but there are also other functions you can use.</p>
<blockquote>
<p>当处理游戏逻辑，交互，动画，相机位置等等具体功能时，这里有一系列不同的事件方法可以使用。常见的模式是在 Update 方法中执行大部分的逻辑任务，当然，也有其他的方法可以使用。</p>
</blockquote>
<hr>
<ul>
<li><strong>FixedUpdate</strong>: FixedUpdate is often called more frequently than Update. It can be called multiple times per frame, if the frame rate is low and it may not be called between frames at all if the frame rate is high. All physics calculations and updates occur immediately after FixedUpdate. When applying movement calculations inside FixedUpdate, you do not need to multiply your values by Time.deltaTime. This is because FixedUpdate is called on a reliable timer, independent of the frame rate.</li>
</ul>
<blockquote>
<p>FixedUpdate 的调用比 Update 更加频繁：当帧率（ frame rate ）较低时，每一帧有可能多次调用 FixedUpdate 方法，但是当帧率较高时，也可能在帧率非常高时，在帧之间根本不会被调用。所有的物理计算和更新会在 FixedUpdate 执行完后立即产生效果。而且，当在 FixedUpdate 中处理移动计算时，也不需要乘上 Time.deltaTime 来弥补帧之间的时间差。因为 FixedUpdate 是基于一个可靠的计时器的定时调用的，与帧率无关。</p>
</blockquote>
<hr>
<ul>
<li><strong>Update</strong>: Update is called once per frame. It is the main workhorse function for frame updates.</li>
</ul>
<blockquote>
<p>Update 方法每帧会调用一次，是帧更新中干活的主力。</p>
</blockquote>
<hr>
<ul>
<li><strong>LateUpdate</strong>: LateUpdate is called once per frame, after Update has finished. Any calculations that are performed in Update will have completed when LateUpdate begins. A common use for LateUpdate would be a following third-person camera. If you make your character move and turn inside Update, you can perform all camera movement and rotation calculations in LateUpdate. This will ensure that the character has moved completely before the camera tracks its position.</li>
</ul>
<blockquote>
<p>LateUpdate 同样会每帧更新一次，但是在 Update 完成之后执行。也就意味着，当 LateUpdate 开始时，Update 中的任何计算行为都将完成。对于 LateUpdate 的应用有一个比较经典的案例，第三人称摄像机跟随。将人物角色的移动等操作放在 Update 中，将摄像机的运动（平移，旋转等等）放在 LateUpdate 中，这就可以确保每一帧镜头的移动都是在人物移动之后进行的。</p>
</blockquote>
<hr>
<h3 id="Animation-update-loop"><a href="#Animation-update-loop" class="headerlink" title="Animation update loop"></a>Animation update loop</h3><p>这一部分是动画更新循环，并不常见，因此暂时不做翻译啦。</p>
<hr>
<h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><blockquote>
<p>渲染（ ，表达，刷墙…… ）</p>
</blockquote>
<hr>
<ul>
<li>OnPreCull: Called before the camera culls the scene. Culling determines which objects are visible to the camera. OnPreCull is called just before culling takes place.</li>
</ul>
<blockquote>
<p>在相机进行剔除之前执行。剔除决定哪些对象对于相机来说是可见的。</p>
</blockquote>
<ul>
<li>OnBecameVisible/OnBecameInvisible: Called when an object becomes visible/invisible to any camera.</li>
</ul>
<blockquote>
<p>在对象相对于相机可见或不可见时调用。</p>
</blockquote>
<ul>
<li>OnWillRenderObject: Called once for each camera if the object is visible.</li>
</ul>
<blockquote>
<p>在对象可见时，每个相机调用一次。</p>
</blockquote>
<ul>
<li>OnPreRender: Called before the camera starts rendering the scene.</li>
</ul>
<blockquote>
<p>在相机开始渲染场景前调用。</p>
</blockquote>
<ul>
<li>OnRenderObject: Called after all regular scene rendering is done. You can use GL class or Graphics.DrawMeshNow to draw custom geometry at this point.</li>
</ul>
<blockquote>
<p>在场景渲染完成后调用，可以通过使用 GL 类或 Graphics.DrawMeshNow 方法绘出图形。</p>
</blockquote>
<ul>
<li>OnPostRender: Called after a camera finishes rendering the scene.</li>
</ul>
<blockquote>
<p>在相机完成场景渲染后调用。</p>
</blockquote>
<ul>
<li>OnRenderImage: Called after scene rendering is complete to allow post-processing of the image, see Post-processing Effects.</li>
</ul>
<blockquote>
<p>在场景完成渲染后调用来处理图像的后处理。</p>
</blockquote>
<ul>
<li><strong>OnGUI</strong>: Called multiple times per frame in response to GUI events. The Layout and Repaint events are processed first, followed by a Layout and keyboard/mouse event for each input event.</li>
</ul>
<blockquote>
<p>OnGUI 用来响应 GUI 事件，每一帧会调用多次。首先处理布 Layout 和 Repaint 事件，然后为每一个输入时间处理 Layout 和 keyboard/mouse 事件。</p>
</blockquote>
<ul>
<li><strong>OnDrawGizmos</strong> Used for drawing Gizmos in the scene view for visualisation purposes.</li>
</ul>
<blockquote>
<p>用来画场景中的小物件（Gizmos）。</p>
</blockquote>
<hr>
<h3 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h3><blockquote>
<p>协程</p>
</blockquote>
<hr>
<p>Normal coroutine updates are run after the Update function returns. A coroutine is a function that can suspend its execution (yield) until the given YieldInstruction finishes. Different uses of Coroutines:</p>
<blockquote>
<p>正常协程的更新在 Update 方法返回之后执行。一个协程实际是一个可以在执行中挂起的方法（ yield ），并在给出的 YieldInstruction 完成时继续执行。</p>
</blockquote>
<ul>
<li>yield The coroutine will continue after all Update functions have been called on the next frame.</li>
</ul>
<blockquote>
<p>下一帧中所有的 Update 方法完成后继续。</p>
</blockquote>
<ul>
<li>yield WaitForSeconds Continue after a specified time delay, after all Update functions have been called for the frame</li>
</ul>
<blockquote>
<p>经过一个特定的时延，并在当前帧的所有 Update 方法完成后继续。</p>
</blockquote>
<ul>
<li>yield WaitForFixedUpdate Continue after all FixedUpdate has been called on all scripts</li>
</ul>
<blockquote>
<p>在所有的 FixedUpdate 完成后继续。</p>
</blockquote>
<p>在我测试的时候，发现 WaitForFixedUpdate 并不是等到所有的 FixedUpdate 执行完成，而是下一次完成就继续执行协程了（ 我测试的版本是 2018.3.6f1，而这篇文档是 2018.4 ）。从上面的老图上也可以看到，当时的 WaitForFixedUpdate 是会等到下一个 FixedUpdate 结束。</p>
<ul>
<li>yield WWW Continue after a WWW download has completed.</li>
</ul>
<blockquote>
<p>在一次 WWW 下载完成后继续。 </p>
</blockquote>
<ul>
<li>yield StartCoroutine Chains the coroutine, and will wait for the MyFunc coroutine to complete first.</li>
</ul>
<blockquote>
<p>连接一个协程，在等待 MyFunc 协程完成后继续。</p>
</blockquote>
<hr>
<h3 id="When-the-Object-is-destroyed"><a href="#When-the-Object-is-destroyed" class="headerlink" title="When the Object is destroyed"></a>When the Object is destroyed</h3><blockquote>
<p>当对象被摧毁</p>
</blockquote>
<hr>
<ul>
<li>OnDestroy: This function is called after all frame updates for the last frame of the object’s existence (the object might be destroyed in response to Object.Destroy or at the closure of a scene).</li>
</ul>
<blockquote>
<p>OnDestroy 方法在对象存在的最后一帧中所有的帧更新结束后调用。对象可以是被 Object.Destory 方法摧毁或由于场景结束。</p>
</blockquote>
<hr>
<h3 id="When-quitting"><a href="#When-quitting" class="headerlink" title="When quitting"></a>When quitting</h3><blockquote>
<p>当退出</p>
</blockquote>
<hr>
<p>These functions get called on all the active objects in your scene:</p>
<blockquote>
<p>这些函数会在场景中所有有效（ active ）上被调用。</p>
</blockquote>
<ul>
<li>OnApplicationQuit: This function is called on all game objects before the application is quit. In the editor it is called when the user stops playmode.</li>
</ul>
<blockquote>
<p>当退出应用时，或用户停止播放。</p>
</blockquote>
<ul>
<li>OnDisable: This function is called when the behaviour becomes disabled or inactive.</li>
</ul>
<blockquote>
<p>当变为非激活（ disable ）或无效（ inactive ）时。</p>
</blockquote>
<hr>
<h2 id="0xff"><a href="#0xff" class="headerlink" title="0xff"></a>0xff</h2><p>最后，我哭我的 surface 笔挂了，随便看看这个 timeline 吧，简单的在第二帧实例化一个无效（ inactive ）的 cube 对象，在第四帧将 cube 设置为有效（ active ）的方法调用情况：</p>
<p><img src="https://Shiheuan.github.io/2019/06/30/UnityLifecycle/lifecycle-timeline.png" alt=""></p>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-Emmmmm"><span class="toc-number">1.</span> <span class="toc-text">0x00 Emmmmm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-FlowChart"><span class="toc-number">2.</span> <span class="toc-text">0x01 FlowChart</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Conclusion"><span class="toc-number">3.</span> <span class="toc-text">0x02 Conclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-Test"><span class="toc-number">4.</span> <span class="toc-text">0x03 Test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-Translate"><span class="toc-number">5.</span> <span class="toc-text">0x04 Translate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First-Scene-Load"><span class="toc-number">5.1.</span> <span class="toc-text">First Scene Load</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gt-%E6%B3%A8%E6%84%8F%E5%BD%93%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%97%B6%EF%BC%8C%E5%85%A8%E9%83%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84-Awake-%E5%92%8C-OnEnable-%E6%96%B9%E6%B3%95%E9%83%BD%E5%B0%86%E4%BC%9A%E5%9C%A8-Start%E3%80%81Update-%E7%AD%89%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E5%9C%A8%E6%B8%B8%E6%88%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">&gt; 注意当对象添加到场景中时，全部脚本中的 Awake 和 OnEnable 方法都将会在 Start、Update 等方法被调用之前执行。当然，在游戏过程中实例化对象时，不能被强制执行此方法。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Editor"><span class="toc-number">6.1.</span> <span class="toc-text">Editor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gt-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">&gt; 编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Before-the-first-frame-update"><span class="toc-number">7.1.</span> <span class="toc-text">Before the first frame update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-between-frames"><span class="toc-number">7.2.</span> <span class="toc-text">In between frames</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B8%A7%E4%B9%8B%E9%97%B4"><span class="toc-number">7.3.</span> <span class="toc-text">在帧之间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Update-Order"><span class="toc-number">7.4.</span> <span class="toc-text">Update Order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animation-update-loop"><span class="toc-number">7.5.</span> <span class="toc-text">Animation update loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rendering"><span class="toc-number">7.6.</span> <span class="toc-text">Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coroutines"><span class="toc-number">7.7.</span> <span class="toc-text">Coroutines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-the-Object-is-destroyed"><span class="toc-number">7.8.</span> <span class="toc-text">When the Object is destroyed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-quitting"><span class="toc-number">7.9.</span> <span class="toc-text">When quitting</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0xff"><span class="toc-number">8.</span> <span class="toc-text">0xff</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://shiheuan.github.io/2019/06/30/UnityLifecycle/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&text=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&is_video=false&description=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Unity 时间方法执行顺序（生命周期）&body=Check out this article: http://shiheuan.github.io/2019/06/30/UnityLifecycle/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&title=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&name=Unity 时间方法执行顺序（生命周期）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://shiheuan.github.io/2019/06/30/UnityLifecycle/&t=Unity 时间方法执行顺序（生命周期）"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Shiheuan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'Shiheuan/Shiheuan.github.io';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'comment';
      var utterances_theme = 'photon-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
